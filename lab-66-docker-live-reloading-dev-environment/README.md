# Lab 66: Docker Live-Reloading Dev Environment

![Difficulty: Medium](https://img.shields.io/badge/Difficulty-Medium-yellow) ![Docker](https://img.shields.io/badge/Docker-2496ED?logo=docker&logoColor=white)

> **Auto-generated lab** - Created on 2026-01-20

## Description

This lab demonstrates how to set up a Docker development environment with live reloading for a simple web application. It covers creating a Dockerfile, using Docker Compose, and leveraging volume mounts for real-time code updates.

## Learning Objectives

- Create a Dockerfile for a basic web application.
- Use Docker Compose to define and manage a development environment.
- Implement live reloading using volume mounts.
- Understand the benefits of Docker for development workflows.

## Prerequisites

- Docker installed and running
- Docker Compose installed
- Basic understanding of Docker concepts (images, containers, volumes)

## Lab Steps

### Step 1: Create a Simple Web Application

First, create a directory for your project and add a basic HTML file, `index.html`. This will be our "web application".

```bash
mkdir live-reload-app
cd live-reload-app
touch index.html
```

Now, add the following content to `index.html`:

```html
<!DOCTYPE html>
<html>
<head>
    <title>Docker Live Reload</title>
</head>
<body>
    <h1>Hello, Docker!</h1>
    <p>This is a simple web application.</p>
</body>
</html>
```

### Step 2: Create a Dockerfile

Create a `Dockerfile` in the same directory as `index.html`. This Dockerfile will use a lightweight HTTP server (e.g., `nginx`) to serve the HTML file.

```bash
touch Dockerfile
```

Add the following content to `Dockerfile`:

```dockerfile
FROM nginx:alpine

COPY index.html /usr/share/nginx/html/

EXPOSE 80

CMD ["nginx", "-g", "daemon off;"]
```

### Step 3: Create a Docker Compose File

Create a `docker-compose.yml` file in the same directory. This file will define the service and configure the volume mount for live reloading.

```bash
touch docker-compose.yml
```

Add the following content to `docker-compose.yml`:

```yaml
version: '3.8'
services:
  web:
    build: .
    ports:
      - "8080:80"
    volumes:
      - .:/usr/share/nginx/html
```

**Explanation:**

*   `build: .` tells Docker Compose to build the image from the Dockerfile in the current directory.
*   `ports: - "8080:80"` maps port 8080 on your host machine to port 80 in the container.
*   `volumes: - .:/usr/share/nginx/html` mounts the current directory (containing `index.html`) to the `/usr/share/nginx/html` directory inside the container. This allows changes to `index.html` on your host machine to be immediately reflected in the running container.

### Step 4: Run the Application with Docker Compose

Run the application using Docker Compose:

```bash
docker-compose up -d
```

This command builds the image and starts the container in detached mode.  `-d` flag runs the container in the background.

Once the container is running, open your web browser and navigate to `http://localhost:8080`. You should see the "Hello, Docker!" message.

### Step 5: Test Live Reloading

Edit the `index.html` file on your host machine. For example, change the heading to "Hello, Live Reload!".

Save the file and refresh your browser. You should see the changes immediately reflected in the browser without rebuilding the image or restarting the container. This is because of the volume mount that synchronizes the files between your host and the container.

### Step 6: Clean Up

Stop and remove the container and network created by docker-compose.

```bash
docker-compose down
```


<details>
<summary> Hints (click to expand)</summary>

1. Ensure Docker Desktop is running before executing Docker commands.
2. Double-check the file paths in your Dockerfile and docker-compose.yml.
3. If you don't see the changes, try clearing your browser cache.
4. Make sure the volume mount path in docker-compose.yml is correct relative to your project directory.

</details>


<details>
<summary>âœ… Solution Notes (spoiler)</summary>

The key to this lab is the volume mount in the `docker-compose.yml` file. This allows for real-time synchronization between the host machine and the container, enabling live reloading.  The `nginx:alpine` image provides a lightweight base for serving static content.

</details>


---

## Notes

- **Difficulty:** Medium
- **Estimated time:** 45-75 minutes
- **Technology:** Docker

##  Cleanup

Don't forget to clean up resources after completing the lab:

```bash
# Example cleanup commands (adjust based on lab content)
docker system prune -f
# or
kubectl delete -f .
# or
helm uninstall <release-name>
```

---

*This lab was auto-generated by the [Lab Generator Bot](../.github/workflows/generate-lab.yml)*
